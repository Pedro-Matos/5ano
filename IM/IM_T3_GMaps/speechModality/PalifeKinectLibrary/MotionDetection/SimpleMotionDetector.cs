
namespace Paelife.KinectFramework.MotionDetection
{
    using System;
    using System.Drawing;
    using System.Drawing.Imaging;

    using AForge.Imaging;
    using AForge.Imaging.Filters;

    /// <summary>
    /// A motion detector that simply compares the current frame with the last frame.
    /// Some image transformations are applied in order to disregard the noise
    /// generated by the cameras.
    /// </summary>
    public class SimpleMotionDetector : IMotionDetector
    {
        private IFilter grayscaleFilter = new GrayscaleBT709();
        private IFilter pixellateFilter = new Pixellate();
        private Difference differenceFilter = new Difference();
        private Threshold thresholdFilter = new Threshold(15);
        private Dilatation dilatationFilter = new Dilatation();

        private FiltersSequence processingFilter1 = new FiltersSequence();

        private int width;	// image width
        private int height;	// image height
        private int pixelsChanged;

        private Bitmap backgroundFrame;
        private Bitmap backgroundPlayerFrame;
        private BitmapData bitmapData;

        private double alarmLevel = 0.035;
        private DateTime lastProcessedImageTime = DateTime.MinValue;
        private TimeSpan processImageInterval = TimeSpan.FromSeconds(0.2);
        private int framesPerSecond = 5;

        private delegate void MotionDetectedEventHandler(object sender, EventArgs e);

        /// <summary>
        /// This field have a default value of 5.
        /// </summary>
        public int FramesPerSecond
        {
            get { return framesPerSecond; }
            set
            {
                framesPerSecond = value;
                processImageInterval = TimeSpan.FromSeconds(((double)1) / ((double)value));
            }
        }

        //! @copydoc IMotionDetector::MotionLevel()
        public double MotionLevel
        {
            get { return (double)pixelsChanged / (width * height); }
        }

        public SimpleMotionDetector()
        {
            processingFilter1.Add(grayscaleFilter);
            processingFilter1.Add(pixellateFilter);
        }

        /// <summary>
        /// This field have a default value of 0.035, which means that if the image 
        /// changes in 3,5% pixels or more, the MotionDetected event is fired.
        /// </summary>
        public double AlarmLevel
        {
            get { return alarmLevel; }
            set { alarmLevel = value; }
        }

        //! @copydoc IMotionDetector::MotionDetected
        public event EventHandler MotionDetected;


        //! @copydoc IMotionDetector::ProcessFrame(ref Bitmap,ref Bitmap)
        public void ProcessFrame(ref Bitmap image, ref Bitmap player)
        {
            if (lastProcessedImageTime + processImageInterval > DateTime.UtcNow)
                return;
                

            if (backgroundFrame == null)
            {
                // create initial backgroung image
                backgroundFrame = processingFilter1.Apply(image);

                backgroundPlayerFrame = processingFilter1.Apply(player);

                // get image dimension
                width = image.Width;
                height = image.Height;

                // just return for the first time
                return;
            }

            Bitmap tmpImage;

            // apply the the first filters sequence
            tmpImage = processingFilter1.Apply(image);

            // set backgroud frame as an overlay for difference filter
            differenceFilter.OverlayImage = backgroundFrame;

            //actualizar o backgroud
            backgroundFrame = tmpImage.Clone(new Rectangle(0, 0, width, height), PixelFormat.Format8bppIndexed);

            // lock temporary image to apply several filters
            bitmapData = tmpImage.LockBits(new Rectangle(0, 0, width, height),
                ImageLockMode.ReadWrite, PixelFormat.Format8bppIndexed);

            // apply difference filter
            differenceFilter.ApplyInPlace(bitmapData);
            // apply threshold filter
            thresholdFilter.ApplyInPlace(bitmapData);
            // apply dilatation filter
            Bitmap tmpImage2 = dilatationFilter.Apply(bitmapData);

            // unlock temporary image
            tmpImage.UnlockBits(bitmapData);
            tmpImage.Dispose();

            Bitmap playerProccessed = processingFilter1.Apply(player);
            Add addFilter = new Add(playerProccessed);
            Bitmap tmpPlayer = addFilter.Apply(backgroundPlayerFrame);

            // calculate amount of changed pixels
            pixelsChanged = CalculateWhitePixels(tmpImage2, tmpPlayer);

            if (MotionLevel >= alarmLevel)
            {
                if (MotionDetected != null)
                    MotionDetected(this, EventArgs.Empty);
            }

            tmpImage2.Dispose();
            tmpPlayer.Dispose();
            backgroundPlayerFrame = playerProccessed;
            //image = backgroundPlayerFrame;

            lastProcessedImageTime = DateTime.UtcNow;
        }


        private int CalculateWhitePixels(Bitmap image, Bitmap player)
        {
            int count = 0;

            // lock difference image
            BitmapData data = image.LockBits(new Rectangle(0, 0, width, height),
                ImageLockMode.ReadOnly, PixelFormat.Format8bppIndexed);

            BitmapData playerData = player.LockBits(new Rectangle(0, 0, width, height),
                ImageLockMode.ReadOnly, PixelFormat.Format8bppIndexed);


            int offset = data.Stride - width;

            unsafe
            {
                byte* ptr = (byte*)data.Scan0.ToPointer();
                byte* ptrPlayer = (byte*)playerData.Scan0.ToPointer();

                for (int y = 0; y < height; y++)
                {
                    for (int x = 0; x < width; x++, ptr++, ptrPlayer++)
                    {
                        if (((*ptrPlayer) >> 7) != 1) //verificar se e' branco
                            count += ((*ptr) >> 7);
                    }
                    ptr += offset;
                    ptrPlayer += offset;
                }
            }
            // unlock image
            image.UnlockBits(data);
            player.UnlockBits(data);

            return count;
        }


        //! @copydoc IMotionDetector::Reset()
        public void Reset()
        {
            if (backgroundFrame != null)
            {
                backgroundFrame.Dispose();
                backgroundFrame = null;
            }
        }
    }
}
